Hardware Accelerator for 1D CNN based Time Series Anomaly Detection
üìå Project Overview
This project implements a hardware accelerator for a 1-Dimensional Convolutional Neural Network (1D CNN) using Verilog HDL.
Designed for the Industrial Internet of Things (IIoT), this accelerator is capable of performing real-time anomaly detection on edge devices (like FPGAs) without relying on cloud processing
1.The system processes time-series vibration data to classify the operational state of industrial motors into three categories
2:Healthy (Class 0)Bearing Fault (Class 1)Rotor Imbalance (Class 2)
üöÄ Why Hardware Acceleration?In industrial settings, sensors generate massive amounts of data. sending all this data to the cloud causes latency (delays), consumes bandwidth, and raises security concerns333333333.By building a dedicated circuit (Hardware Accelerator) to run the AI model directly on the device, we achieve:Low Latency: Immediate fault detection.Data Privacy: Data stays on the device.Reliability: Works even without an internet connection4.üß† The AI Model ArchitectureThe hardware implements a specific feed-forward neural network designed for short time-series sequences5:Input Layer: Takes in a sequence of 8 sensor samples6.Conv1D Layer: Applies filters (kernels) to extract features from the vibration data7.ReLU Activation: Removes negative values to introduce non-linearity ($f(x) = max(0, x)$)8.Dense (Fully Connected) Layer: Maps the features to the final 3 output classes9.Output: A classification score indicating the motor's health status10.‚öôÔ∏è Hardware Architecture & MethodologyThe project translates the AI model into digital logic circuits. The design is modular, controlled by Finite State Machines (FSMs) to manage the flow of data11.üìÇ Key Verilog Modulescnn_top.v (Master Controller):This is the "Brain" of the accelerator. It coordinates the entire process. It triggers the Convolution layer, waits for it to finish, moves data through the ReLU activation, triggers the Dense layer, and outputs the final result12121212.mac_unit.v (The Calculator):A pipelined Multiply-Accumulate unit. Since Neural Networks are mostly multiplication and addition, this unit is optimized to do these calculations quickly using a 3-stage pipeline13131313.dual_port_bram.v (Memory):On-chip memory (Block RAM) used to store:Input sensor data.Neural Network weights (learned parameters).Intermediate features passed between layers14.conv1d_bram_fsm.v:A dedicated controller for the Convolutional Layer. It manages the "sliding window" calculation over the input data15.compute_dense_fsm.v:A dedicated controller for the Dense Layer. It performs the matrix multiplication required to produce the final classification scores16.compute_relu.v:A simple logic block that checks if a number is negative. If it is, it converts it to zero17.üîÑ How It Works (Execution Flow)When the accelerator is started, the cnn_top module orchestrates the following pipeline18:Data Loading: Input sensor data and model weights are loaded into the BRAMs (simulated via testbench).Convolution: The conv1d_bram_fsm reads data, calculates features using the mac_unit, and signals when done.Activation: cnn_top reads the convolution results, passes them through compute_relu, and writes the activated data to the intermediate memory.Classification: compute_dense_fsm reads the activated features, calculates scores for all 3 classes, and identifies the maximum score.Result: The system outputs final_class_out (0, 1, or 2).üõ†Ô∏è Simulation & VerificationThe design was verified using the Xilinx Vivado Simulator19.Test StrategyWe created comprehensive testbenches (cnn_top_tb_comprehensive.v) that:Load the memory with synthetic data.Load specific weights designed to force the network to detect specific faults.Run the accelerator.Automatically compare the hardware output against the expected mathematical result20.ResultsThe simulation successfully verified the logic for all three cases:‚úÖ Case 0: Correctly identified "Healthy" state.‚úÖ Case 1: Correctly identified "Bearing Fault".‚úÖ Case 2: Correctly identified "Rotor Imbalance"21.üîÆ Future ScopeHardware Implementation: Synthesize the design onto a physical FPGA board (e.g., Xilinx Artix-7/Zynq).Real-time Inputs: Integrate an Analog-to-Digital Converter (ADC) to read real vibration sensors.Processor Integration: Add an AXI-Lite interface to allow a CPU to communicate with the accelerator22.
